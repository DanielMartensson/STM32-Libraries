/*
 * SSD1306.c
 *
 *  Created on: 4 juin 2020
 *      Author: Daniel MÃ¥rtensson
 */

#include "SSD1306.h"

static I2C_HandleTypeDef *i2c_;
static uint8_t gddram[4][128];
#define address 0x78 // SSD1306 128x32 can only have one I2C address

/* Fonts */
#define CHAR_WIDTH 6
#define CHAR_HEIGHT 8
static char fonts[96][6] = {
		{0x00,0x00,0x00,0x00,0x00,0x00}, //
		{0x2f,0x00,0x00,0x00,0x00,0x00}, // !
		{0x03,0x00,0x03,0x00,0x00,0x00}, // "
		{0x12,0x3f,0x12,0x12,0x3f,0x12}, // #
		{0x2e,0x2a,0x7f,0x2a,0x3a,0x00}, // $
		{0x23,0x13,0x08,0x04,0x32,0x31}, // %
		{0x10,0x2a,0x25,0x2a,0x10,0x20}, // &
		{0x02,0x01,0x00,0x00,0x00,0x00}, // '
		{0x1e,0x21,0x00,0x00,0x00,0x00}, // (
		{0x21,0x1e,0x00,0x00,0x00,0x00}, // )
		{0x08,0x2a,0x1c,0x2a,0x08,0x08}, // *
		{0x08,0x08,0x3e,0x08,0x08,0x08}, // +
		{0x80,0x60,0x00,0x00,0x00,0x00}, // ,
		{0x08,0x08,0x08,0x08,0x08,0x00}, // -
		{0x30,0x30,0x00,0x00,0x00,0x00}, // .
		{0x20,0x10,0x08,0x04,0x02,0x00}, // /
		{0x1e,0x31,0x29,0x25,0x23,0x1e}, // 0
		{0x22,0x21,0x3f,0x20,0x20,0x20}, // 1
		{0x32,0x29,0x29,0x29,0x29,0x26}, // 2
		{0x12,0x21,0x21,0x25,0x25,0x1a}, // 3
		{0x18,0x14,0x12,0x3f,0x10,0x10}, // 4
		{0x17,0x25,0x25,0x25,0x25,0x19}, // 5
		{0x1e,0x25,0x25,0x25,0x25,0x18}, // 6
		{0x01,0x01,0x31,0x09,0x05,0x03}, // 7
		{0x1a,0x25,0x25,0x25,0x25,0x1a}, // 8
		{0x06,0x29,0x29,0x29,0x29,0x1e}, // 9
		{0x24,0x00,0x00,0x00,0x00,0x00}, // :
		{0x80,0x64,0x00,0x00,0x00,0x00}, // ;
		{0x08,0x14,0x22,0x00,0x00,0x00}, // <
		{0x14,0x14,0x14,0x14,0x14,0x00}, // =
		{0x22,0x14,0x08,0x00,0x00,0x00}, // >
		{0x02,0x01,0x01,0x29,0x05,0x02}, // ?
		{0x1e,0x21,0x2d,0x2b,0x2d,0x0e}, // @
		{0x3e,0x09,0x09,0x09,0x09,0x3e}, // A
		{0x3f,0x25,0x25,0x25,0x25,0x1a}, // B
		{0x1e,0x21,0x21,0x21,0x21,0x12}, // C
		{0x3f,0x21,0x21,0x21,0x12,0x0c}, // D
		{0x3f,0x25,0x25,0x25,0x25,0x21}, // E
		{0x3f,0x05,0x05,0x05,0x05,0x01}, // F
		{0x1e,0x21,0x21,0x21,0x29,0x1a}, // G
		{0x3f,0x04,0x04,0x04,0x04,0x3f}, // H
		{0x21,0x21,0x3f,0x21,0x21,0x21}, // I
		{0x10,0x20,0x20,0x20,0x20,0x1f}, // J
		{0x3f,0x04,0x0c,0x0a,0x11,0x20}, // K
		{0x3f,0x20,0x20,0x20,0x20,0x20}, // L
		{0x3f,0x02,0x04,0x04,0x02,0x3f}, // M
		{0x3f,0x02,0x04,0x08,0x10,0x3f}, // N
		{0x1e,0x21,0x21,0x21,0x21,0x1e}, // O
		{0x3f,0x09,0x09,0x09,0x09,0x06}, // P
		{0x1e,0x21,0x29,0x31,0x21,0x1e}, // Q
		{0x3f,0x09,0x09,0x09,0x19,0x26}, // R
		{0x12,0x25,0x25,0x25,0x25,0x18}, // S
		{0x01,0x01,0x01,0x3f,0x01,0x01}, // T
		{0x1f,0x20,0x20,0x20,0x20,0x1f}, // U
		{0x0f,0x10,0x20,0x20,0x10,0x0f}, // V
		{0x1f,0x20,0x10,0x10,0x20,0x1f}, // W
		{0x21,0x12,0x0c,0x0c,0x12,0x21}, // X
		{0x01,0x02,0x0c,0x38,0x04,0x02}, // Y
		{0x21,0x31,0x29,0x25,0x23,0x21}, // Z
		{0x3f,0x21,0x00,0x00,0x00,0x00}, // [
		{0x02,0x04,0x08,0x10,0x20,0x00}, // "\"
		{0x21,0x3f,0x00,0x00,0x00,0x00}, // ]
		{0x04,0x02,0x3f,0x02,0x04,0x00}, // ^
		{0x40,0x40,0x40,0x40,0x40,0x40}, // _
		{0x01,0x02,0x00,0x00,0x00,0x00}, // `
		{0x10,0x30,0x2a,0x2a,0x3c,0x00}, // a
		{0x3f,0x24,0x24,0x24,0x18,0x00}, // b
		{0x0c,0x14,0x22,0x22,0x00,0x00}, // c
		{0x18,0x24,0x24,0x24,0x3f,0x00}, // d
		{0x1c,0x2c,0x2a,0x2a,0x24,0x00}, // e
		{0x3e,0x05,0x01,0x00,0x00,0x00}, // f
		{0x18,0x28,0xa4,0xa4,0x7c,0x00}, // g
		{0x3f,0x04,0x04,0x0c,0x30,0x00}, // h
		{0x24,0x3d,0x20,0x00,0x00,0x00}, // i
		{0x20,0x40,0x40,0x3d,0x00,0x00}, // j
		{0x3f,0x0c,0x12,0x20,0x00,0x00}, // k
		{0x1f,0x20,0x20,0x00,0x00,0x00}, // l
		{0x3e,0x02,0x3c,0x02,0x3c,0x00}, // m
		{0x3e,0x02,0x02,0x02,0x3c,0x00}, // n
		{0x0c,0x14,0x22,0x32,0x0c,0x00}, // o
		{0xfc,0x24,0x24,0x24,0x18,0x00}, // p
		{0x18,0x24,0x24,0x24,0xfc,0x80}, // q
		{0x3c,0x04,0x02,0x02,0x00,0x00}, // r
		{0x24,0x2c,0x2a,0x2a,0x10,0x00}, // s
		{0x02,0x1f,0x22,0x20,0x00,0x00}, // t
		{0x1e,0x20,0x20,0x20,0x1e,0x00}, // u
		{0x06,0x18,0x20,0x18,0x06,0x00}, // v
		{0x1e,0x30,0x1c,0x30,0x0e,0x00}, // w
		{0x22,0x14,0x08,0x14,0x22,0x00}, // x
		{0x0c,0x10,0xa0,0xa0,0x7c,0x00}, // y
		{0x22,0x32,0x2a,0x26,0x22,0x22}, // z
		{0x0c,0x3f,0x21,0x00,0x00,0x00}, // {
		{0x3f,0x00,0x00,0x00,0x00,0x00}, // |
		{0x21,0x3f,0x0c,0x00,0x00,0x00}, // }
		{0x02,0x01,0x02,0x01,0x00,0x00}, // ~
		{0x00,0x00,0x00,0x00,0x00,0x00}
};

static void command(uint8_t byte) {
	uint8_t buffer[2];
	buffer[0] = 0x00;
	buffer[1] = byte;
	HAL_I2C_Master_Transmit(i2c_, address, buffer, 2, 50);
}

static void update() {
	command(0x21); // Column address
	command(0);   // Column start address (0 = reset)
	command(128 - 1); // Display width

	command(0x22); // Page address
	command(0x0); // Page start address (0 = reset)
	command(0x03); // Page end address

	//SEND data in 16byte packs
	uint8_t buffer[17];
	buffer[0] = 0x40;
	for (uint16_t line = 0; line < 4; line++) {
		for (uint8_t x = 0; x < 127; x += 16) {
			for (uint8_t i = 1; i < 17; i++) {
				buffer[i] = gddram[line][x + i - 1];
			}
			HAL_I2C_Master_Transmit(i2c_, address, buffer, 17, 1000);
		}
	}
}

static void pixel(uint8_t x, uint8_t y, bool color){
	if(x<128 && y<32)
	{
		uint8_t pixel = 0x01;
		uint8_t line = y>>3;
		uint8_t byte = pixel<<(y%8);
		if(color)
			gddram[line][x] |= byte;
		else
			gddram[line][x] &= ~byte;
	}
	update();
}

void SSD1306_init(I2C_HandleTypeDef *i2c) {
	i2c_ = i2c;
	// Init sequence
	command(0xAE); // Display off
	command(0xD5); // Set display clock div
	command(0x80);
	command(0xA8); // Set multiplex
	command(32 - 1); // 32 in heigth
	command(0xD3); // Set display offset
	command(0x0);
	command(0x40); // Set start line
	command(0x8D); // Charge pump
	command(0x14);
	command(0x20); // Set memory mode
	command(0x00);
	command(0xA0 | 0x1); // Serge map
	command(0xC8); // Communication scan dectect
	command(0xDA); // Set compins
	command(0x02);
	command(0x81); // Set constrast
	command(0x8F);
	command(0xd9); // Set precharge
	command(0xF1);
	command(0xDB); // Set V communication detect
	command(0x40); // Set start line
	command(0xA4); // Display on resume
	command(0xA6); // Normal display
	command(0x2E); // Deactivate scroll
	command(0xAF); // Display on

	// Init gddram
	for (uint8_t i = 0; i < 4; i++)
		for (uint8_t j = 0; j < 128; j++)
			gddram[i][j] = 0x00;
}

void SSD1306_invert_display(bool invert) {
  if (invert) {
    command(0xA7); // Invert display
  } else {
    command(0xA6); // Normal dipslay
  }
}

/*
 * Activate a right handed scroll for rows start through stop
 * The display is 16 rows tall. To scroll the whole display, run: SSD1306_start_scroll_right(0x00, 0x0F)
 */
void SSD1306_start_scroll_right(uint8_t start, uint8_t stop){
  command(0x26); // Right horizontal scroll
  command(0X00);
  command(start);
  command(0X00);
  command(stop);
  command(0X00);
  command(0XFF);
  command(0x2F); // Active scroll
}

/*
 * Activate a right handed scroll for rows start through stop
 * The display is 16 rows tall. To scroll the whole display, run: SSD1306_start_scroll_left(0x00, 0x0F)
 */
void SSD1306_start_scroll_left(uint8_t start, uint8_t stop){
  command(0x27); // Left horizontal scroll
  command(0X00);
  command(start);
  command(0X00);
  command(stop);
  command(0X00);
  command(0XFF);
  command(0x2F); // Active scroll
}

/*
 * Activate a diagonal scroll for rows start through stop
 * The display is 16 rows tall. To scroll the whole display, run: SSD1306_start_scroll_diagonal_right(0x00, 0x0F)
 */
void SSD1306_start_scroll_diagonal_right(uint8_t start, uint8_t stop){
  command(0xA3); // Set vertical scroll area
  command(0X00);
  command(32);   // Height
  command(0x29); // Vertical and right horizontal scroll
  command(0X00);
  command(start);
  command(0X00);
  command(stop);
  command(0X01);
  command(0x2F); // Active scroll
}

/*
 * Activate a diagonal scroll for rows start through stop
 * The display is 16 rows tall. To scroll the whole display, run: start_scroll_diagonal_left(0x00, 0x0F)
 */
void SSD1306_start_scroll_diagonal_left(uint8_t start, uint8_t stop){
  command(0xA3); // Set vertical scroll area
  command(0X00);
  command(32);   // Height
  command(0x2A); // Vertical and left horizontal scroll
  command(0X00);
  command(start);
  command(0X00);
  command(stop);
  command(0X01);
  command(0x2F); // Active scroll
}

void SSD1306_stop_scroll(){
  command(0x2E); // Deactivate scroll
}

/*
 *	Dim the display
 *	dim = 1: display is dimmed
 *	dim = 0: display is normal
 */
void SSD1306_dim(uint8_t dim) {
  uint8_t contrast;
  if (dim)
    contrast = 0;
  else
      contrast = 0xCF;

  command(0x81); // Set constrast
  command(contrast);
}

void SSD1306_draw_line(uint8_t x0, uint8_t x1, uint8_t y0, uint8_t y1){
	// Swap
	int16_t y = 0;
	if(x0 > x1){
		y = x0;
		x0 = x1;
		x1 = y;
	}
	if(y0 > y1){
		y = y0;
		y0 = y1;
		y1 = y;
	}

	int16_t dx = x1 - x0;
	int16_t dy = y1 - y0;
	int16_t D = 2*dy - dx;
	y = y0;

	for (uint8_t x = x0; x <= x1; x++) {
	  pixel(x, y ,true);
	  if (D > 0) {
	    y++;
	    D = D - 2*dx;
	  }
	  D = D + 2*dy;
	}
}

void SSD1306_write_text(char* str, uint8_t x, uint8_t y) {
    while (*str) {
    	SSD1306_draw_char(*str++, x, y);
        x += CHAR_WIDTH;
    }
}

void SSD1306_draw_char(char c, uint8_t x, uint8_t y) {
    // Convert the character to an index
    c = c & 0x7F;
    if (c < ' ') {
        c = 0;
    } else {
        c -= ' ';
    }

    // Draw pixels
    for (uint8_t j = 0; j < CHAR_WIDTH; j++) {
        for (uint8_t i = 0; i < CHAR_HEIGHT; i++) {
        	pixel(x + j, y + i, fonts[(uint8_t) c][j] & (1 << i));
        }
    }
}

void SSD1306_write_bitmap(uint8_t x, uint8_t y, uint8_t* bitmap, uint8_t rows, uint8_t columns){
	// Draw pixels
	for (uint8_t i = 0; i < rows; i++) {
		for (uint8_t j = 0; j < columns; j++) {
			for(uint8_t k = 0; k < 8; k++){
				pixel(x + 8*j + k, y + i, bitmap[columns*i + j] & (0x80 >> k));
			}
	    }
	}
}
